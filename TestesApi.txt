Exemplos de Uso da API
A API dispõe de endpoints para criação, consulta, teste e visualização gráfica de cada tipo de autômato. Abaixo, são apresentados alguns exemplos de configuração e entradas de teste.

AFD
Exemplo 1: AFD que aceita a palavra "ab"

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["a", "b"],
  "transitions": {
    "q0": { "a": "q1" },
    "q1": { "b": "q2" }
  },
  "initial_state": "q0",
  "final_states": ["q2"]
}
Entrada para teste:
"ab"

Exemplo 2: AFD que aceita números binários múltiplos de 3

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "transitions": {
    "q0": { "0": "q0", "1": "q1" },
    "q1": { "0": "q2", "1": "q0" },
    "q2": { "0": "q1", "1": "q2" }
  },
  "initial_state": "q0",
  "final_states": ["q0"]
}
Entradas para teste:
"0", "11", "110" (aceitas) e "101" (rejeitada).

Exemplo 3: AFD que aceita strings que terminam em "01"

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "transitions": {
    "q0": { "0": "q1", "1": "q0" },
    "q1": { "0": "q1", "1": "q2" },
    "q2": { "0": "q1", "1": "q0" }
  },
  "initial_state": "q0",
  "final_states": ["q2"]
}
Entradas para teste:
"01", "101" (aceitas) e "10" (rejeitada).

NFA
Exemplo 1: NFA que aceita "a" ou "b"

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["a", "b"],
  "transitions": {
    "q0": { "a": ["q1"], "b": ["q2"] },
    "q1": {},
    "q2": {}
  },
  "initial_state": "q0",
  "final_states": ["q1", "q2"]
}
Entradas para teste:
"a" e "b".

Exemplo 2: NFA que aceita "ab" ou "ba"

Configuração JSON:

{
  "states": ["q0", "q1", "q2", "q3"],
  "input_symbols": ["a", "b"],
  "transitions": {
    "q0": { "a": ["q1"], "b": ["q2"] },
    "q1": { "b": ["q3"] },
    "q2": { "a": ["q3"] },
    "q3": {}
  },
  "initial_state": "q0",
  "final_states": ["q3"]
}
Entradas para teste:
"ab", "ba" (aceitas) e "aa" (rejeitada).

Exemplo 3: NFA que aceita qualquer sequência terminando em "01"

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "transitions": {
    "q0": { "0": ["q0", "q1"], "1": ["q0"] },
    "q1": { "1": ["q2"] },
    "q2": {}
  },
  "initial_state": "q0",
  "final_states": ["q2"]
}
Entradas para teste:
"101", "1101" (aceitas) e "111" (rejeitada).

DPDA
Exemplo 1: DPDA que reconhece "aaabbb"

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["a", "b"],
  "stack_symbols": ["A", "$"],
  "transitions": {
    "q0": {
      "a": { "$": ["q0", "A$"], "A": ["q0", "AA"] },
      "b": { "A": ["q1", ""] }
    },
    "q1": { "b": { "A": ["q1", ""] } }
  },
  "initial_state": "q0",
  "initial_stack_symbol": "$",
  "final_states": ["q1"],
  "acceptance_mode": "empty_stack"
}
Entradas para teste:
"aaabbb" (aceita), "aabbb" e "aaaabbbb" (rejeitadas).

Exemplo 2: DPDA que reconhece palíndromos de "a" e "b"

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["a", "b"],
  "stack_symbols": ["A", "B", "#"],
  "transitions": {
    "q0": {
      "a": { "#": ["q0", "A#"], "A": ["q0", "AA"], "B": ["q0", "AB"], "": ["q1", ""] },
      "b": { "#": ["q0", "B#"], "A": ["q0", "BA"], "B": ["q0", "BB"], "": ["q1", ""] }
    },
    "q1": {
      "a": { "A": ["q1", ""] },
      "b": { "B": ["q1", ""] },
      "": { "#": ["q2", "#"] }
    }
  },
  "initial_state": "q0",
  "initial_stack_symbol": "#",
  "final_states": ["q2"],
  "acceptance_mode": "final_state"
}
Entradas para teste:
"abba", "aba" (aceitas) e "abab" (rejeitada).

Exemplo 3: DPDA que aceita cadeias da forma 0ⁿ1ⁿ

Configuração JSON:

{
  "states": ["q0", "q1"],
  "input_symbols": ["0", "1"],
  "stack_symbols": ["X", "$"],
  "transitions": {
    "q0": {
      "0": { "$": ["q0", "X$"], "X": ["q0", "XX"] },
      "1": { "X": ["q1", ""] }
    },
    "q1": {
      "1": { "X": ["q1", ""] }
    }
  },
  "initial_state": "q0",
  "initial_stack_symbol": "$",
  "final_states": ["q1"],
  "acceptance_mode": "empty_stack"
}
Entradas para teste:
"0011", "000111" (aceitas) e "011" (rejeitada).

TM
Exemplo 1: TM que inverte "01" para "10"

Configuração JSON:

{
  "states": ["q0", "q1", "q2", "q3"],
  "input_symbols": ["0", "1"],
  "tape_symbols": ["0", "1", "X", "_"],
  "transitions": {
    "q0": { "0": ["q1", "X", "R"], "1": ["q2", "X", "R"] },
    "q1": { "1": ["q3", "0", "R"] },
    "q2": { "0": ["q3", "1", "R"] }
  },
  "initial_state": "q0",
  "blank_symbol": "_",
  "final_states": ["q3"]
}
Entradas para teste:
"01" (aceita e inverte para “10”), "10" (depende da configuração).

Exemplo 2: TM que soma 1 em um número binário

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "tape_symbols": ["0", "1", "_"],
  "transitions": {
    "q0": { "0": ["q0", "0", "R"], "1": ["q0", "1", "R"], "_": ["q1", "1", "L"] },
    "q1": {}
  },
  "initial_state": "q0",
  "blank_symbol": "_",
  "final_states": ["q1"]
}
Entradas para teste:
"1010", "1100", "1111".

Exemplo 3: TM que reconhece "aaabbb"

Configuração JSON:

{
  "states": ["q0", "q1", "q2", "q3"],
  "input_symbols": ["a", "b"],
  "tape_symbols": ["a", "b", "X", "_"],
  "transitions": {
    "q0": { "a": ["q1", "X", "R"] },
    "q1": { "b": ["q2", "X", "R"] },
    "q2": { "_": ["q3", "_", "L"] }
  },
  "initial_state": "q0",
  "blank_symbol": "_",
  "final_states": ["q3"]
}
Entradas para teste:
"aaabbb" (aceita), "aaabb" e "aaaabbb" (rejeitadas).

NPDA
Exemplo 1: NPDA que aceita 0ⁿ1ⁿ

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "stack_symbols": ["X", "$"],
  "transitions": {
    "q0": {
      "0": {
        "$": [["q0", "X$"]],
        "X": [["q0", "XX"]]
      },
      "1": {
        "X": [["q1", ""]]
      }
    },
    "q1": {
      "1": {
        "X": [["q1", ""]]
      },
      "": {
        "$": [["q2", "$"]]
      }
    }
  },
  "initial_state": "q0",
  "initial_stack_symbol": "$",
  "final_states": ["q2"],
  "acceptance_mode": "final_state"
}
Entradas para teste:
"0011", "000111".

Exemplo 2: NPDA que reconhece palíndromos de "a" e "b"

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["a", "b"],
  "stack_symbols": ["A", "B", "#"],
  "transitions": {
    "q0": {
      "a": {
        "#": [["q0", "A#"]],
        "A": [["q0", "AA"], ["q1", ""]],
        "B": [["q0", "AB"]]
      },
      "b": {
        "#": [["q0", "B#"]],
        "A": [["q0", "BA"]],
        "B": [["q0", "BB"], ["q1", ""]]
      },
      "": {
        "#": [["q2", "#"]]
      }
    },
    "q1": {
      "a": { "A": [["q1", ""]] },
      "b": { "B": [["q1", ""]] },
      "": { "#": [["q2", "#"]] }
    }
  },
  "initial_state": "q0",
  "initial_stack_symbol": "#",
  "final_states": ["q2"],
  "acceptance_mode": "final_state"
}
Entradas para teste:
"abba", "aba".

Exemplo 3: NPDA que aceita ww^R (palíndromos)

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["a", "b"],
  "stack_symbols": ["A", "B", "$"],
  "transitions": {
    "q0": {
      "a": {"$": [["q0", "A$"]], "A": [["q0", "AA"], ["q1", ""]], "B": [["q0", "AB"]]},
      "b": {"$": [["q0", "B$"]], "A": [["q0", "BA"]], "B": [["q0", "BB"], ["q1", ""]]},
      "": {"$": [["q1", "$"]]}
    },
    "q1": {
      "a": {"A": [["q1", ""]]},
      "b": {"B": [["q1", ""]]},
      "": {"$": [["q2", "$"]]}
    }
  },
  "initial_state": "q0",
  "initial_stack_symbol": "$",
  "final_states": ["q2"],
  "acceptance_mode": "empty_stack"
}
Entradas para teste:
"abba", "abaaba".

NTM
Exemplo 1: NTM que reconhece 0ⁿ1ⁿ

Configuração JSON:

{
  "states": ["q0", "q1", "q2", "q3"],
  "input_symbols": ["0", "1"],
  "tape_symbols": ["0", "1", "X", "_"],
  "transitions": {
    "q0": { "0": [["q1", "X", "R"]], "_": [["q3", "_", "R"]] },
    "q1": { "0": [["q1", "0", "R"]], "1": [["q2", "X", "L"]] },
    "q2": { "0": [["q2", "0", "L"]], "X": [["q0", "X", "R"]] }
  },
  "initial_state": "q0",
  "blank_symbol": "_",
  "final_states": ["q3"]
}
Entradas para teste:
"0011", "000111".

Exemplo 2: NTM que verifica se um número binário é par

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "tape_symbols": ["0", "1", "_"],
  "transitions": {
    "q0": { "0": [["q0", "0", "R"]], "1": [["q1", "1", "R"]], "_": [["q2", "_", "R"]] },
    "q1": { "0": [["q0", "0", "R"]], "1": [["q1", "1", "R"]], "_": [["q2", "_", "R"]] }
  },
  "initial_state": "q0",
  "blank_symbol": "_",
  "final_states": ["q2"]
}
Entradas para teste:
"1010" (par), "101" (ímpar, rejeitada).

Exemplo 3: NTM que copia um número binário

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "tape_symbols": ["0", "1", "_"],
  "transitions": {
    "q0": { "0": [["q1", "0", "R"]], "1": [["q1", "1", "R"]], "_": [["q2", "_", "R"]] },
    "q1": { "0": [["q1", "0", "R"]], "1": [["q1", "1", "R"]], "_": [["q2", "_", "R"]] }
  },
  "initial_state": "q0",
  "blank_symbol": "_",
  "final_states": ["q2"]
}
Entradas para teste:
"1010", "1100".

MNTM
Exemplo 1: MNTM que copia um número binário de uma fita para outra

Configuração JSON:

{
  "states": ["q0", "q1", "q2"],
  "input_symbols": ["0", "1"],
  "tape_symbols": ["0", "1", "#"],
  "n_tapes": 2,
  "transitions": {
    "q0": {
      "1,#": [ ["q0", [ ["1", "R"], ["1", "R"] ]] ],
      "0,#": [ ["q0", [ ["0", "R"], ["#", "N"] ]] ],
      "#,#": [ ["q1", [ ["#", "N"], ["#", "N"] ]] ]
    }
  },
  "initial_state": "q0",
  "blank_symbol": "#",
  "final_states": ["q1"]
}
Entradas para teste:
"1010", "1101".

Exemplo 2: MNTM que multiplica por 2 um número binário

Configuração JSON:

{
  "states": ["q0", "q1"],
  "input_symbols": ["0", "1"],
  "tape_symbols": ["0", "1", "#"],
  "n_tapes": 2,
  "transitions": {
    "q0": {
      "1,#": [ ["q1", [ ["1", "R"], ["1", "R"] ]] ]
    }
  },
  "initial_state": "q0",
  "blank_symbol": "#",
  "final_states": ["q1"]
}
Entradas para teste:
"101", "110".